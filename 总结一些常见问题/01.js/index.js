/*  
  面试流程：
    1. 笔试（比重不太）
    2. 人事面试
    3. 技术面试（基本技术人员）
    4. 技术面试（项目经理） / 技术总监 CTO （可能有N轮）
    5. 人事面试

  1. 作用域（链）
    1）什么是作用域？
      作用域是一块代码的地盘。
    2）有什么作用
      隔离变量，让不同作用域的变量不会冲突
    3）作用域的分类
      全局作用域
      局部作用域
        函数作用域 function () {}
        块级作用域（ES6） if () {} / switch {} case / while () {} / for(){} ...
    4) 作用域方向：是由内向外的，由小向大
    5）作用域链：多个上下级关系的作用域形成的叫做作用域链
      用来查找变量。先在自身作用域找，在找上一级作用域，直到全局作用域
      如果某个作用域找到了，就不找了，如果在全局作用域都没找到，就会报错 xxx is not defined    

  2. 原型（链）
    原型实际上指的是两个原型属性：prototype 和 __proto__
    prototype 叫做显示原型属性  __proto__ 叫做隐式原型属性
    prototype属性：
      所有函数都有显示原型属性。但是ES6中箭头函数没有显示原型。（为什么？）
      显示属性属性的值是一个对象，这个对象叫做原型对象
      原型对象上至少有两个内容：
        constructor 函数构造方法，指向函数本身
        __proto__ 指向 Object.prototype 
      有什么用：通过原型链方式给实例对象使用  
    __proto__属性：
      所有对象都有隐式原型属性。（函数、数组也有）
        所有对象都可以叫做实例对象，因为对象一定是new某个构造函数产生的(有可能是你new的，也有可能是JS引擎解析它new的)
          const obj = {} --> const obj = new Object()
      实例对象的隐式原型属性指向其对应构造函数显示原型属性（原型对象）
    怎么找构造函数？
      对象
        你new某个构造函数的产生的实例对象，实例对象的构造函数就是它
        不是你new的，默认构造函数是Object（比如说正常原型对象，它的构造函数都是Object）
      数组
        构造函数都是Array
      函数  
        构造函数都是Function
        Array/Object/Function都是new Function产生的，
        所以可以看做Array/Object/Function是Function的实例对象

     原型链：由多个隐式原型属性组成的叫做原型链
        它的作用用来查找对象上的属性的
        先在自身找，再沿着隐式原型链一层层找，找到了就返回值
        直到原型链的尽头 Object.prototype.__proto__ ，它的值为null，但是返回值为undefined   

      应用：用来实现继承

  3. 闭包
    概念：一个包含被引用外层函数局部变量“对象”，在Chrome开发者工作调试查看叫做Closure
    如何产生：
      1. 函数嵌套
      2. 内部函数引用外部函数的局部变量
      3. 执行外部函数
    作用: 
      1. 延长局部变量的生命周期（存活时间）
      2. 能让函数外部操作（读/写）函数内部的数据
    生命周期：
      产生：当嵌套内部函数定义执行完就产生
      死亡：当嵌套内部函数成为垃圾对象(让内部函数没有任何变量指向它，没有引用关系)，内部函数就会死，内部函数保存的闭包也死
        const fn = null
    缺点：容易导致内存泄漏，及时释放  
    开发中应用：
      高阶函数（执行函数返回值是另外一个函数） 
        --> 在React使用高阶函数复用事件回调函数（控制Modal显示/隐藏）
      研究源码 --> vue双向数据绑定原理 -> 保存this/vm实例对象

  4. 面向对象 - 继承
    继承 / 封装 / 多态
    JS
      ES5 原型 + 构造函数 
      ES6 
        class定义类 
        extends继承父类 
        super调用父类构造函数，同时也能使用父类的方法
        子类通过this可以使用父类的属性和方法
        static定义类的方法 --> ES7 扩展定义类的属性

    TS 
      接口：用来定义类/函数的形状（类有哪些属性和方法）interface
      类实现接口 implements
      接口继承接口来复用接口 extends
      接口继承类，从而得到类定义的属性方法（用得较少）
      public 定义方法/属性，代表所有类都可以访问
      protected 定义受保护的方法/属性，只有自己和继承子类可以使用（实例对象不可以使用）
      private 定义私有的方法/属性，只有自己可以用。（继承子类和实例对象都不可以使用）
      readonly 只读属性
      abstract 抽象类 不能new调用，只能被子类继承使用
      get/set 描述属性读/写方法

  5. 事件轮询/循环机制
    事件机制：DOM事件执行机制
      捕获 --> 目标 --> 冒泡
    事件轮询/循环机制：JS异步代码执行机制
      JS引擎会从上到下依次执行所有代码。当遇到同步代码，会从上到下依次执行
      当遇到异步代码，开启一个分线程去干活（比如DOM事件，会调用DOM事件管理模块给目标元素绑定事件）
      主线程继续解析其他代码，当主线程执行全局所有代码时，此时开启事件轮询/循环
      轮询异步回调队列（不同回调函数放入不同的队列中，统称为回调队列），依次取出，同步执行
      什么时候异步回调队列有回调函数呢？
        比如定时器到点了，定时器管理模块（分线程）会将定时器回调函数添加到异步回调队列中
        用户触发了DOM事件，DOM事件管理模块（分线程）将事件回调函数添加到异步回调队列中
      主线程JS引擎只负责取出回调函数执行它~  

  问题：事件轮询机制并不能准确判断异步代码执行的先后顺序：
    Nodejs事件轮询机制
      分为六个阶段
        timers 定时器阶段（定时器回调队列）
        pending 
        idle、prepare
        poll 轮询阶段（I/O回调函数队列，如fs读写文件回调函数）
          如果定时器没到点或者没有定时器，也没有调用过setImmedia函数，
          那么事件轮询就一直在poll阶段停留，后面都不去了
          只有满足以上两个条件中至少一个，才会去下一个阶段
        check 检查阶段（setImmedia回调函数队列）
        close

    宏/微任务
      对异步代码进行了优先级划分
      微任务：优先级更高的异步任务（微任务可以在任意阶段执行）
        process.nextTick() 优先级最高
        promise.then/catch/finally() 依次执行
      宏任务：优先级更低的异步任务（宏任务只能在特点阶段执行）
        setTimeout/setInterval
        I/O
        setImmedia
*/