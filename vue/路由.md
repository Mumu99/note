### 路由

* `vue`是可以使用 `vue-router`，实现单页面应用（页面不刷新的情况，可以显示不同的内容（不同组件切换的显示结果）

* 路由：
  * 前端路由和后端路由前端路由：
    * 就足一种映射关系，链接地址对应着某个组件，跳转地址，对应的组件内容就会显示
    * 链接地址发生变化，根据地址，在页面的指令的位置可以渲染对应的组件内容就会显示
    * 链接地址，就是一个a标答中有href，href有地址
    * 路由链接`router-link`标答中有to='地址'，最终在页面中会渲染成一对a标签，a标签就是所谓的链接地址
    * 路由视图: `router-view`标签的位置最终会渲染路由地址对应的组件内容
    * 组件: 普通组件和路由组件
    * 普通组件：一般定义在 components目录中，路由组件，般定义在 pages目录中
    * 路由的使用：首先通过 `npm install vue- router 或 yarn add vue-router`安装这个包定义一个 router目录，定义一个 `index.js`文件
    * 先引入路由包，声明使用路由，实例化路由器对象，并暴露出去，在 `main.js`中引入路由器对象并在实例化`vue`的时候注册路由器
    * 普通的组件一旦进行路由的配置了，此时这个普通的组件就变成了路由组件
    * 定义路由的时候，每个路由都是一个对象 Route，每个对象中都有path属性和 component属性
    * 路由在跳转的时候，浏览器的地址栏中有的时候会有#，有的时候会没有
    * 配置路由的时候可以通过mode属性来设置浏览器的地址栏中是否有
    * 默认是hash模式，有，如果mode；" history’此时浏览器的地址栏中没有
    * 路由：一级路由，二级路由，三级路由
    * 路由重定向：{path："地址'， redirect：地址"}
    * 路由传参:可以通过`params`和`query`的形式-----props---meta
    * prams形式:布尔模式,对象模式,函数模式
    * 一旦路由器对象被注册(`main.js`中),每个组件的实例对象中都有一个$router属性
    * 通过router-link配合router-view,不写js代码的方式可以直接实现路由跳转,这种方式:声明式路由
    * 如果通过js代码的方式实现路由跳转,这种方式:编程式路由
    * router.push()和router.replace() 两个方法可以实现编程式路由
    * push()有上一次的历史记录
    * replace()没有上一次历史记录
    * back()可以返回上一次的路由
    * router-link和push()都有上一次记录,跳转结果一样,router-link这种方式是否可以实现replace的效果,可以,只需要在router-link标签上添加一个replace属性
    * keep-alive 标签是`Vue`中提供的内置组件,可以用来缓存路由组件
    * router-view 标签可以进行传参,在需要该参数的组件中使用props进行接口,即可使用了